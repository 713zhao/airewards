{
  "id": "snapshot_1761789208258_w2uoz02np",
  "approvalId": "approval_1761789208197_czsf1q14w",
  "approvalTitle": "AI Rewards System Design Specification",
  "version": 1,
  "timestamp": "2025-10-30T01:53:28.258Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# AI Rewards System - Design Specification\r\n\r\n## 1. Architecture Overview\r\n\r\n### 1.1 High-Level Architecture\r\n\r\nThe AI Rewards System follows a clean architecture pattern with clear separation of concerns, ensuring maintainability, testability, and scalability. The architecture consists of the following layers:\r\n\r\n```\r\n┌─────────────────────────────────────────────────────────┐\r\n│                    Presentation Layer                    │\r\n├─────────────────────────────────────────────────────────┤\r\n│                    Application Layer                     │\r\n├─────────────────────────────────────────────────────────┤\r\n│                     Domain Layer                        │\r\n├─────────────────────────────────────────────────────────┤\r\n│                Infrastructure Layer                      │\r\n└─────────────────────────────────────────────────────────┘\r\n```\r\n\r\n### 1.2 Technology Stack\r\n\r\n#### Frontend Framework\r\n- **Flutter 3.24+**: Cross-platform mobile development\r\n- **Dart 3.5+**: Programming language\r\n- **Material Design 3**: UI/UX framework\r\n\r\n#### Backend Services\r\n- **Firebase Authentication**: User authentication and authorization\r\n- **Cloud Firestore**: NoSQL document database\r\n- **Firebase Analytics**: User behavior tracking\r\n- **Firebase Cloud Messaging**: Push notifications\r\n- **Firebase Performance**: App performance monitoring\r\n\r\n#### Local Storage\r\n- **SQLite**: Offline data storage via `sqflite` package\r\n- **Hive**: Key-value storage for app preferences\r\n- **Shared Preferences**: Simple key-value storage\r\n\r\n#### State Management\r\n- **Bloc Pattern**: Using `flutter_bloc` package for predictable state management\r\n- **Provider**: Dependency injection and service location\r\n\r\n#### Additional Services\r\n- **Google AdMob**: Advertisement integration\r\n- **Google Sign-In**: Google OAuth authentication\r\n- **Local Notifications**: `flutter_local_notifications`\r\n\r\n## 2. System Architecture\r\n\r\n### 2.1 Clean Architecture Implementation\r\n\r\n```\r\nlib/\r\n├── main.dart                           # Application entry point\r\n├── core/                              # Core utilities and base classes\r\n│   ├── constants/                     # App constants and configurations\r\n│   ├── errors/                        # Error handling and exceptions\r\n│   ├── network/                       # Network utilities and connectivity\r\n│   ├── services/                      # Core services (DI, logging, etc.)\r\n│   ├── theme/                         # App theming and styles\r\n│   └── utils/                         # Utility functions and helpers\r\n├── features/                          # Feature-based modules\r\n│   ├── authentication/                # Authentication feature\r\n│   │   ├── data/                      # Data layer (repositories, data sources)\r\n│   │   ├── domain/                    # Domain layer (entities, use cases)\r\n│   │   └── presentation/              # Presentation layer (UI, bloc)\r\n│   ├── rewards/                       # Reward management feature\r\n│   ├── redemption/                    # Redemption feature\r\n│   ├── categories/                    # Category management feature\r\n│   ├── history/                       # History tracking feature\r\n│   ├── profile/                       # User profile feature\r\n│   └── advertisements/                # AdMob integration feature\r\n└── shared/                           # Shared components and widgets\r\n    ├── widgets/                       # Reusable UI components\r\n    ├── models/                        # Shared data models\r\n    └── services/                      # Shared services\r\n```\r\n\r\n### 2.2 Data Flow Architecture\r\n\r\n```\r\n┌─────────────┐    ┌─────────────┐    ┌─────────────┐\r\n│   UI/Bloc   │───▶│  Use Cases  │───▶│ Repository  │\r\n└─────────────┘    └─────────────┘    └─────────────┘\r\n       ▲                                      │\r\n       │                                      ▼\r\n┌─────────────┐                       ┌─────────────┐\r\n│   States    │◀──────────────────────│Data Sources │\r\n└─────────────┘                       └─────────────┘\r\n                                              │\r\n                                              ▼\r\n                                  ┌─────────────────────┐\r\n                                  │  Firebase/SQLite    │\r\n                                  └─────────────────────┘\r\n```\r\n\r\n## 3. Feature Design Specifications\r\n\r\n### 3.1 Authentication System\r\n\r\n#### 3.1.1 Authentication Flow\r\n```dart\r\n// Domain Entity\r\nclass User {\r\n  final String id;\r\n  final String email;\r\n  final String? displayName;\r\n  final String? photoUrl;\r\n  final AuthProvider provider;\r\n  final DateTime createdAt;\r\n  final DateTime lastLoginAt;\r\n}\r\n\r\n// Authentication States\r\nabstract class AuthState {}\r\nclass AuthInitial extends AuthState {}\r\nclass AuthLoading extends AuthState {}\r\nclass AuthSuccess extends AuthState { final User user; }\r\nclass AuthFailure extends AuthState { final String message; }\r\nclass AuthUnauthenticated extends AuthState {}\r\n```\r\n\r\n#### 3.1.2 Authentication Repository Interface\r\n```dart\r\nabstract class AuthRepository {\r\n  Future<Either<Failure, User>> signInWithGoogle();\r\n  Future<Either<Failure, User>> signInWithEmail(String email, String password);\r\n  Future<Either<Failure, User>> signUpWithEmail(String email, String password);\r\n  Future<Either<Failure, void>> signOut();\r\n  Future<Either<Failure, User?>> getCurrentUser();\r\n  Stream<User?> get authStateChanges;\r\n}\r\n```\r\n\r\n#### 3.1.3 Offline Authentication Strategy\r\n- Cache user authentication tokens securely using Flutter Secure Storage\r\n- Store basic user profile data locally for offline access\r\n- Implement token refresh mechanism when connectivity is restored\r\n- Provide guest mode for offline-only usage with data sync on sign-in\r\n\r\n### 3.2 Reward Points Management System\r\n\r\n#### 3.2.1 Reward Domain Model\r\n```dart\r\nclass RewardEntry {\r\n  final String id;\r\n  final String userId;\r\n  final int points;\r\n  final String description;\r\n  final String categoryId;\r\n  final DateTime createdAt;\r\n  final DateTime? updatedAt;\r\n  final bool isSynced;\r\n  final RewardType type; // EARNED, ADJUSTED, BONUS\r\n}\r\n\r\nclass RewardCategory {\r\n  final String id;\r\n  final String name;\r\n  final Color color;\r\n  final IconData icon;\r\n  final bool isDefault;\r\n  final DateTime createdAt;\r\n}\r\n```\r\n\r\n#### 3.2.2 Reward Repository Interface\r\n```dart\r\nabstract class RewardRepository {\r\n  Future<Either<Failure, List<RewardEntry>>> getRewardHistory({\r\n    int? limit,\r\n    DateTime? startDate,\r\n    DateTime? endDate,\r\n    String? categoryId,\r\n  });\r\n  Future<Either<Failure, RewardEntry>> addRewardEntry(RewardEntry entry);\r\n  Future<Either<Failure, RewardEntry>> updateRewardEntry(RewardEntry entry);\r\n  Future<Either<Failure, void>> deleteRewardEntry(String entryId);\r\n  Future<Either<Failure, int>> getTotalPoints(String userId);\r\n  Stream<int> watchTotalPoints(String userId);\r\n}\r\n```\r\n\r\n#### 3.2.3 Offline Data Strategy\r\n- Use SQLite as local database with auto-sync capabilities\r\n- Implement conflict resolution for concurrent edits\r\n- Queue offline changes for synchronization when online\r\n- Maintain data integrity with transaction-based operations\r\n\r\n### 3.3 Redemption System\r\n\r\n#### 3.3.1 Redemption Domain Model\r\n```dart\r\nclass RedemptionOption {\r\n  final String id;\r\n  final String title;\r\n  final String description;\r\n  final int requiredPoints;\r\n  final String categoryId;\r\n  final bool isActive;\r\n  final DateTime? expiryDate;\r\n  final String? imageUrl;\r\n}\r\n\r\nclass RedemptionTransaction {\r\n  final String id;\r\n  final String userId;\r\n  final String optionId;\r\n  final int pointsUsed;\r\n  final DateTime redeemedAt;\r\n  final RedemptionStatus status;\r\n  final String? notes;\r\n}\r\n\r\nenum RedemptionStatus { PENDING, COMPLETED, CANCELLED, EXPIRED }\r\n```\r\n\r\n#### 3.3.2 Redemption Repository Interface\r\n```dart\r\nabstract class RedemptionRepository {\r\n  Future<Either<Failure, List<RedemptionOption>>> getRedemptionOptions();\r\n  Future<Either<Failure, RedemptionTransaction>> redeemPoints(RedemptionRequest request);\r\n  Future<Either<Failure, List<RedemptionTransaction>>> getRedemptionHistory(String userId);\r\n  Future<Either<Failure, bool>> canRedeem(String userId, int points);\r\n}\r\n```\r\n\r\n### 3.4 Category Management System\r\n\r\n#### 3.4.1 Category Domain Model\r\n```dart\r\nclass CategoryManager {\r\n  static const List<RewardCategory> defaultCategories = [\r\n    RewardCategory(id: 'fitness', name: 'Fitness', color: Colors.green),\r\n    RewardCategory(id: 'work', name: 'Work', color: Colors.blue),\r\n    RewardCategory(id: 'personal', name: 'Personal', color: Colors.orange),\r\n    RewardCategory(id: 'bonus', name: 'Bonus', color: Colors.purple),\r\n  ];\r\n}\r\n```\r\n\r\n#### 3.4.2 Category Repository Interface\r\n```dart\r\nabstract class CategoryRepository {\r\n  Future<Either<Failure, List<RewardCategory>>> getRewardCategories();\r\n  Future<Either<Failure, List<RedemptionCategory>>> getRedemptionCategories();\r\n  Future<Either<Failure, RewardCategory>> addRewardCategory(RewardCategory category);\r\n  Future<Either<Failure, RewardCategory>> updateRewardCategory(RewardCategory category);\r\n  Future<Either<Failure, void>> deleteRewardCategory(String categoryId);\r\n}\r\n```\r\n\r\n## 4. User Interface Design\r\n\r\n### 4.1 Navigation Architecture\r\n\r\n#### 4.1.1 Bottom Navigation Structure\r\n```dart\r\nenum BottomNavItem {\r\n  dashboard(icon: Icons.dashboard, label: 'Dashboard'),\r\n  rewards(icon: Icons.stars, label: 'Rewards'),\r\n  redemption(icon: Icons.shopping_cart, label: 'Redeem'),\r\n  history(icon: Icons.history, label: 'History'),\r\n  profile(icon: Icons.person, label: 'Profile');\r\n}\r\n```\r\n\r\n#### 4.1.2 Screen Hierarchy\r\n```\r\n┌─────────────────────────────────────────┐\r\n│            Splash Screen                │\r\n└─────────────────┬───────────────────────┘\r\n                  │\r\n┌─────────────────▼───────────────────────┐\r\n│         Authentication Flow             │\r\n├─────────────────────────────────────────┤\r\n│  ├── Login Screen                       │\r\n│  ├── Register Screen                    │\r\n│  ├── Forgot Password Screen             │\r\n│  └── Biometric Setup Screen             │\r\n└─────────────────┬───────────────────────┘\r\n                  │\r\n┌─────────────────▼───────────────────────┐\r\n│            Main App Shell               │\r\n├─────────────────────────────────────────┤\r\n│  ├── Dashboard                          │\r\n│  │   ├── Points Summary                 │\r\n│  │   ├── Recent Activity               │\r\n│  │   ├── Quick Actions                 │\r\n│  │   └── Achievement Cards             │\r\n│  │                                     │\r\n│  ├── Rewards Management                │\r\n│  │   ├── Add Reward Screen             │\r\n│  │   ├── Edit Reward Screen            │\r\n│  │   └── Reward Categories             │\r\n│  │                                     │\r\n│  ├── Redemption                        │\r\n│  │   ├── Available Rewards             │\r\n│  │   ├── Redemption Confirmation       │\r\n│  │   └── Redemption Categories         │\r\n│  │                                     │\r\n│  ├── History                           │\r\n│  │   ├── Reward History                │\r\n│  │   ├── Redemption History            │\r\n│  │   └── Export Options                │\r\n│  │                                     │\r\n│  └── Profile                           │\r\n│      ├── User Settings                 │\r\n│      ├── Category Management           │\r\n│      ├── Backup & Sync                 │\r\n│      └── About & Support               │\r\n└─────────────────────────────────────────┘\r\n```\r\n\r\n### 4.2 UI Component Design System\r\n\r\n#### 4.2.1 Core Components\r\n```dart\r\n// Custom App Bar with AdMob integration\r\nclass RewardsAppBar extends StatelessWidget implements PreferredSizeWidget {\r\n  final String title;\r\n  final List<Widget>? actions;\r\n  final bool showAd;\r\n  \r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return Column(\r\n      children: [\r\n        if (showAd) const AdBannerWidget(),\r\n        AppBar(title: Text(title), actions: actions),\r\n      ],\r\n    );\r\n  }\r\n}\r\n\r\n// Reward Card Component\r\nclass RewardCard extends StatelessWidget {\r\n  final RewardEntry reward;\r\n  final VoidCallback? onTap;\r\n  final VoidCallback? onEdit;\r\n  final VoidCallback? onDelete;\r\n}\r\n\r\n// Points Display Widget\r\nclass PointsDisplayWidget extends StatelessWidget {\r\n  final int totalPoints;\r\n  final int availablePoints;\r\n  final bool showAnimation;\r\n}\r\n\r\n// Category Chip Widget\r\nclass CategoryChip extends StatelessWidget {\r\n  final RewardCategory category;\r\n  final bool isSelected;\r\n  final VoidCallback? onSelected;\r\n}\r\n```\r\n\r\n#### 4.2.2 Theme Configuration\r\n```dart\r\nclass AppTheme {\r\n  static ThemeData lightTheme = ThemeData(\r\n    useMaterial3: true,\r\n    colorScheme: ColorScheme.fromSeed(\r\n      seedColor: const Color(0xFF2E7D32), // Green primary\r\n      brightness: Brightness.light,\r\n    ),\r\n    appBarTheme: const AppBarTheme(\r\n      centerTitle: true,\r\n      elevation: 0,\r\n    ),\r\n    cardTheme: CardTheme(\r\n      elevation: 2,\r\n      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),\r\n    ),\r\n  );\r\n\r\n  static ThemeData darkTheme = ThemeData(\r\n    useMaterial3: true,\r\n    colorScheme: ColorScheme.fromSeed(\r\n      seedColor: const Color(0xFF4CAF50), // Light green primary\r\n      brightness: Brightness.dark,\r\n    ),\r\n  );\r\n}\r\n```\r\n\r\n## 5. Database Design\r\n\r\n### 5.1 Firebase Firestore Schema\r\n\r\n#### 5.1.1 Collections Structure\r\n```\r\nusers/\r\n├── {userId}/\r\n│   ├── profile: UserProfile\r\n│   ├── settings: UserSettings\r\n│   └── subcollections/\r\n│       ├── rewards/\r\n│       │   └── {rewardId}: RewardEntry\r\n│       ├── redemptions/\r\n│       │   └── {redemptionId}: RedemptionTransaction\r\n│       ├── categories/\r\n│       │   └── {categoryId}: RewardCategory\r\n│       └── achievements/\r\n│           └── {achievementId}: Achievement\r\n\r\nglobal/\r\n├── redemption_options/\r\n│   └── {optionId}: RedemptionOption\r\n├── default_categories/\r\n│   └── {categoryId}: RewardCategory\r\n└── app_config/\r\n    └── settings: AppConfiguration\r\n```\r\n\r\n#### 5.1.2 Document Schemas\r\n```dart\r\n// Firestore Document Schemas\r\nclass FirestoreSchemas {\r\n  static Map<String, dynamic> userProfile(User user) => {\r\n    'uid': user.id,\r\n    'email': user.email,\r\n    'displayName': user.displayName,\r\n    'photoUrl': user.photoUrl,\r\n    'provider': user.provider.name,\r\n    'totalPoints': 0,\r\n    'availablePoints': 0,\r\n    'createdAt': FieldValue.serverTimestamp(),\r\n    'lastLoginAt': FieldValue.serverTimestamp(),\r\n    'settings': {\r\n      'notifications': true,\r\n      'theme': 'system',\r\n      'language': 'en',\r\n      'biometricAuth': false,\r\n    }\r\n  };\r\n\r\n  static Map<String, dynamic> rewardEntry(RewardEntry entry) => {\r\n    'points': entry.points,\r\n    'description': entry.description,\r\n    'categoryId': entry.categoryId,\r\n    'type': entry.type.name,\r\n    'createdAt': FieldValue.serverTimestamp(),\r\n    'updatedAt': entry.updatedAt?.millisecondsSinceEpoch,\r\n  };\r\n\r\n  static Map<String, dynamic> redemptionTransaction(RedemptionTransaction transaction) => {\r\n    'optionId': transaction.optionId,\r\n    'pointsUsed': transaction.pointsUsed,\r\n    'status': transaction.status.name,\r\n    'redeemedAt': FieldValue.serverTimestamp(),\r\n    'notes': transaction.notes,\r\n  };\r\n}\r\n```\r\n\r\n### 5.2 Local SQLite Schema\r\n\r\n#### 5.2.1 Database Tables\r\n```sql\r\n-- Users table for offline authentication\r\nCREATE TABLE users (\r\n    id TEXT PRIMARY KEY,\r\n    email TEXT UNIQUE NOT NULL,\r\n    display_name TEXT,\r\n    photo_url TEXT,\r\n    provider TEXT NOT NULL,\r\n    total_points INTEGER DEFAULT 0,\r\n    available_points INTEGER DEFAULT 0,\r\n    created_at INTEGER NOT NULL,\r\n    last_login_at INTEGER NOT NULL,\r\n    is_synced INTEGER DEFAULT 0\r\n);\r\n\r\n-- Reward entries table\r\nCREATE TABLE reward_entries (\r\n    id TEXT PRIMARY KEY,\r\n    user_id TEXT NOT NULL,\r\n    points INTEGER NOT NULL,\r\n    description TEXT NOT NULL,\r\n    category_id TEXT NOT NULL,\r\n    type TEXT NOT NULL,\r\n    created_at INTEGER NOT NULL,\r\n    updated_at INTEGER,\r\n    is_synced INTEGER DEFAULT 0,\r\n    FOREIGN KEY (user_id) REFERENCES users (id)\r\n);\r\n\r\n-- Reward categories table\r\nCREATE TABLE reward_categories (\r\n    id TEXT PRIMARY KEY,\r\n    user_id TEXT,\r\n    name TEXT NOT NULL,\r\n    color INTEGER NOT NULL,\r\n    icon_code INTEGER NOT NULL,\r\n    is_default INTEGER DEFAULT 0,\r\n    created_at INTEGER NOT NULL,\r\n    is_synced INTEGER DEFAULT 0,\r\n    FOREIGN KEY (user_id) REFERENCES users (id)\r\n);\r\n\r\n-- Redemption options table (cached from Firestore)\r\nCREATE TABLE redemption_options (\r\n    id TEXT PRIMARY KEY,\r\n    title TEXT NOT NULL,\r\n    description TEXT,\r\n    required_points INTEGER NOT NULL,\r\n    category_id TEXT,\r\n    is_active INTEGER DEFAULT 1,\r\n    expiry_date INTEGER,\r\n    image_url TEXT,\r\n    last_synced INTEGER NOT NULL\r\n);\r\n\r\n-- Redemption transactions table\r\nCREATE TABLE redemption_transactions (\r\n    id TEXT PRIMARY KEY,\r\n    user_id TEXT NOT NULL,\r\n    option_id TEXT NOT NULL,\r\n    points_used INTEGER NOT NULL,\r\n    status TEXT NOT NULL,\r\n    redeemed_at INTEGER NOT NULL,\r\n    notes TEXT,\r\n    is_synced INTEGER DEFAULT 0,\r\n    FOREIGN KEY (user_id) REFERENCES users (id)\r\n);\r\n\r\n-- Sync queue table for offline operations\r\nCREATE TABLE sync_queue (\r\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n    table_name TEXT NOT NULL,\r\n    record_id TEXT NOT NULL,\r\n    operation TEXT NOT NULL, -- INSERT, UPDATE, DELETE\r\n    data TEXT, -- JSON data for INSERT/UPDATE\r\n    created_at INTEGER NOT NULL,\r\n    retry_count INTEGER DEFAULT 0,\r\n    last_error TEXT\r\n);\r\n```\r\n\r\n## 6. Integration Design\r\n\r\n### 6.1 Google AdMob Integration\r\n\r\n#### 6.1.1 Ad Placement Strategy\r\n```dart\r\nclass AdManager {\r\n  static const String appId = 'ca-app-pub-XXXXXXXXXXXXXXXX~XXXXXXXXXX';\r\n  static const String bannerAdUnitId = 'ca-app-pub-XXXXXXXXXXXXXXXX/XXXXXXXXXX';\r\n  static const String interstitialAdUnitId = 'ca-app-pub-XXXXXXXXXXXXXXXX/XXXXXXXXXX';\r\n\r\n  // Banner ads on top of main screens\r\n  static const List<String> bannerScreens = [\r\n    '/dashboard',\r\n    '/rewards',\r\n    '/redemption',\r\n    '/history',\r\n  ];\r\n\r\n  // Interstitial ads on specific actions\r\n  static const Map<String, int> interstitialTriggers = {\r\n    'redemption_complete': 3, // Show after every 3rd redemption\r\n    'reward_milestone': 1000, // Show when reaching point milestones\r\n  };\r\n}\r\n\r\nclass AdBannerWidget extends StatefulWidget {\r\n  @override\r\n  State<AdBannerWidget> createState() => _AdBannerWidgetState();\r\n}\r\n\r\nclass _AdBannerWidgetState extends State<AdBannerWidget> {\r\n  BannerAd? _bannerAd;\r\n  bool _isLoaded = false;\r\n\r\n  @override\r\n  void initState() {\r\n    super.initState();\r\n    _loadBannerAd();\r\n  }\r\n\r\n  void _loadBannerAd() {\r\n    _bannerAd = BannerAd(\r\n      adUnitId: AdManager.bannerAdUnitId,\r\n      size: AdSize.banner,\r\n      request: const AdRequest(),\r\n      listener: BannerAdListener(\r\n        onAdLoaded: (_) => setState(() => _isLoaded = true),\r\n        onAdFailedToLoad: (ad, error) => ad.dispose(),\r\n      ),\r\n    )..load();\r\n  }\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    if (_bannerAd != null && _isLoaded) {\r\n      return Container(\r\n        height: _bannerAd!.size.height.toDouble(),\r\n        child: AdWidget(ad: _bannerAd!),\r\n      );\r\n    }\r\n    return const SizedBox.shrink();\r\n  }\r\n}\r\n```\r\n\r\n### 6.2 Firebase Services Integration\r\n\r\n#### 6.2.1 Authentication Service\r\n```dart\r\nclass FirebaseAuthService implements AuthRepository {\r\n  final FirebaseAuth _firebaseAuth;\r\n  final GoogleSignIn _googleSignIn;\r\n\r\n  @override\r\n  Future<Either<Failure, User>> signInWithGoogle() async {\r\n    try {\r\n      final GoogleSignInAccount? googleUser = await _googleSignIn.signIn();\r\n      if (googleUser == null) return Left(AuthFailure('Sign in cancelled'));\r\n\r\n      final GoogleSignInAuthentication googleAuth = await googleUser.authentication;\r\n      final credential = GoogleAuthProvider.credential(\r\n        accessToken: googleAuth.accessToken,\r\n        idToken: googleAuth.idToken,\r\n      );\r\n\r\n      final UserCredential userCredential = \r\n          await _firebaseAuth.signInWithCredential(credential);\r\n      \r\n      final user = _mapFirebaseUser(userCredential.user!);\r\n      await _syncUserProfile(user);\r\n      \r\n      return Right(user);\r\n    } catch (e) {\r\n      return Left(AuthFailure(e.toString()));\r\n    }\r\n  }\r\n\r\n  @override\r\n  Stream<User?> get authStateChanges {\r\n    return _firebaseAuth.authStateChanges()\r\n        .map((firebaseUser) => firebaseUser != null \r\n            ? _mapFirebaseUser(firebaseUser) \r\n            : null);\r\n  }\r\n}\r\n```\r\n\r\n#### 6.2.2 Firestore Service\r\n```dart\r\nclass FirestoreService {\r\n  final FirebaseFirestore _firestore;\r\n  \r\n  Future<void> addRewardEntry(String userId, RewardEntry entry) async {\r\n    final batch = _firestore.batch();\r\n    \r\n    // Add reward entry\r\n    final rewardRef = _firestore\r\n        .collection('users')\r\n        .doc(userId)\r\n        .collection('rewards')\r\n        .doc(entry.id);\r\n    batch.set(rewardRef, FirestoreSchemas.rewardEntry(entry));\r\n    \r\n    // Update user points\r\n    final userRef = _firestore.collection('users').doc(userId);\r\n    batch.update(userRef, {\r\n      'totalPoints': FieldValue.increment(entry.points),\r\n      'availablePoints': FieldValue.increment(entry.points),\r\n    });\r\n    \r\n    await batch.commit();\r\n  }\r\n\r\n  Stream<int> watchUserPoints(String userId) {\r\n    return _firestore\r\n        .collection('users')\r\n        .doc(userId)\r\n        .snapshots()\r\n        .map((doc) => doc.data()?['availablePoints'] ?? 0);\r\n  }\r\n}\r\n```\r\n\r\n### 6.3 Offline Synchronization\r\n\r\n#### 6.3.1 Sync Service Architecture\r\n```dart\r\nclass SyncService {\r\n  final FirestoreService _firestoreService;\r\n  final LocalDatabaseService _localDbService;\r\n  final ConnectivityService _connectivityService;\r\n\r\n  Future<void> syncAllData() async {\r\n    if (!await _connectivityService.hasConnection()) return;\r\n\r\n    try {\r\n      // Sync pending local changes to Firestore\r\n      await _syncLocalToRemote();\r\n      \r\n      // Pull latest data from Firestore\r\n      await _syncRemoteToLocal();\r\n      \r\n      // Clean up successfully synced items\r\n      await _cleanupSyncQueue();\r\n    } catch (e) {\r\n      // Log error and schedule retry\r\n      await _scheduleRetry();\r\n    }\r\n  }\r\n\r\n  Future<void> _syncLocalToRemote() async {\r\n    final pendingSync = await _localDbService.getPendingSyncItems();\r\n    \r\n    for (final item in pendingSync) {\r\n      try {\r\n        switch (item.operation) {\r\n          case SyncOperation.INSERT:\r\n            await _firestoreService.insertRecord(item);\r\n            break;\r\n          case SyncOperation.UPDATE:\r\n            await _firestoreService.updateRecord(item);\r\n            break;\r\n          case SyncOperation.DELETE:\r\n            await _firestoreService.deleteRecord(item);\r\n            break;\r\n        }\r\n        await _localDbService.markSynced(item.id);\r\n      } catch (e) {\r\n        await _localDbService.incrementRetryCount(item.id, e.toString());\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n## 7. Security Design\r\n\r\n### 7.1 Data Encryption\r\n\r\n#### 7.1.1 Local Data Security\r\n```dart\r\nclass SecureStorageService {\r\n  final FlutterSecureStorage _secureStorage;\r\n  \r\n  static const AndroidOptions _androidOptions = AndroidOptions(\r\n    encryptedSharedPreferences: true,\r\n  );\r\n  \r\n  static const IOSOptions _iosOptions = IOSOptions(\r\n    accessibility: IOSAccessibility.first_unlock_this_device,\r\n  );\r\n\r\n  Future<void> storeAuthToken(String token) async {\r\n    await _secureStorage.write(\r\n      key: 'auth_token',\r\n      value: token,\r\n      aOptions: _androidOptions,\r\n      iOptions: _iosOptions,\r\n    );\r\n  }\r\n\r\n  Future<void> storeBiometricKey(String key) async {\r\n    await _secureStorage.write(\r\n      key: 'biometric_key',\r\n      value: key,\r\n      aOptions: _androidOptions,\r\n      iOptions: _iosOptions,\r\n    );\r\n  }\r\n}\r\n```\r\n\r\n#### 7.1.2 Network Security\r\n```dart\r\nclass NetworkSecurityConfig {\r\n  static final Dio dio = Dio()\r\n    ..interceptors.addAll([\r\n      LogInterceptor(responseBody: false),\r\n      InterceptorsWrapper(\r\n        onRequest: (options, handler) {\r\n          options.headers['Authorization'] = 'Bearer ${AuthService.token}';\r\n          handler.next(options);\r\n        },\r\n      ),\r\n    ]);\r\n\r\n  static const Duration connectTimeout = Duration(seconds: 10);\r\n  static const Duration receiveTimeout = Duration(seconds: 30);\r\n}\r\n```\r\n\r\n### 7.2 Biometric Authentication\r\n\r\n#### 7.2.1 Biometric Service Implementation\r\n```dart\r\nclass BiometricAuthService {\r\n  final LocalAuthentication _localAuth;\r\n\r\n  Future<bool> isBiometricAvailable() async {\r\n    final isAvailable = await _localAuth.canCheckBiometrics;\r\n    final isDeviceSupported = await _localAuth.isDeviceSupported();\r\n    return isAvailable && isDeviceSupported;\r\n  }\r\n\r\n  Future<bool> authenticateWithBiometrics() async {\r\n    try {\r\n      final authenticated = await _localAuth.authenticate(\r\n        localizedReason: 'Authenticate to access your rewards',\r\n        options: const AuthenticationOptions(\r\n          biometricOnly: true,\r\n          stickyAuth: true,\r\n        ),\r\n      );\r\n      return authenticated;\r\n    } catch (e) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  Future<List<BiometricType>> getAvailableBiometrics() async {\r\n    return await _localAuth.getAvailableBiometrics();\r\n  }\r\n}\r\n```\r\n\r\n## 8. Performance Optimization\r\n\r\n### 8.1 State Management Optimization\r\n\r\n#### 8.1.1 Bloc Optimization Patterns\r\n```dart\r\n// Optimized Reward Bloc with debouncing and caching\r\nclass RewardBloc extends Bloc<RewardEvent, RewardState> {\r\n  final RewardRepository _repository;\r\n  Timer? _debounceTimer;\r\n  static const _debounceDuration = Duration(milliseconds: 300);\r\n\r\n  @override\r\n  Stream<RewardState> mapEventToState(RewardEvent event) async* {\r\n    if (event is LoadRewards) {\r\n      yield* _mapLoadRewardsToState(event);\r\n    } else if (event is SearchRewards) {\r\n      yield* _mapSearchRewardsToState(event);\r\n    }\r\n  }\r\n\r\n  Stream<RewardState> _mapSearchRewardsToState(SearchRewards event) async* {\r\n    _debounceTimer?.cancel();\r\n    _debounceTimer = Timer(_debounceDuration, () {\r\n      add(LoadRewards(searchQuery: event.query));\r\n    });\r\n  }\r\n}\r\n```\r\n\r\n### 8.2 Database Optimization\r\n\r\n#### 8.2.1 SQLite Indexing Strategy\r\n```sql\r\n-- Performance indexes\r\nCREATE INDEX idx_reward_entries_user_created \r\nON reward_entries(user_id, created_at DESC);\r\n\r\nCREATE INDEX idx_reward_entries_category \r\nON reward_entries(category_id);\r\n\r\nCREATE INDEX idx_redemption_transactions_user_date \r\nON redemption_transactions(user_id, redeemed_at DESC);\r\n\r\nCREATE INDEX idx_sync_queue_status \r\nON sync_queue(table_name, operation, created_at);\r\n```\r\n\r\n#### 8.2.2 Pagination Implementation\r\n```dart\r\nclass PaginatedRewardRepository extends RewardRepository {\r\n  static const int pageSize = 20;\r\n\r\n  @override\r\n  Future<Either<Failure, PaginatedResult<RewardEntry>>> getRewardHistory({\r\n    int page = 1,\r\n    String? categoryFilter,\r\n    DateTime? startDate,\r\n    DateTime? endDate,\r\n  }) async {\r\n    try {\r\n      final offset = (page - 1) * pageSize;\r\n      final rewards = await _localDbService.getRewards(\r\n        limit: pageSize,\r\n        offset: offset,\r\n        categoryFilter: categoryFilter,\r\n        startDate: startDate,\r\n        endDate: endDate,\r\n      );\r\n      \r\n      final totalCount = await _localDbService.getRewardsCount(\r\n        categoryFilter: categoryFilter,\r\n        startDate: startDate,\r\n        endDate: endDate,\r\n      );\r\n\r\n      return Right(PaginatedResult(\r\n        items: rewards,\r\n        totalCount: totalCount,\r\n        currentPage: page,\r\n        hasNextPage: totalCount > page * pageSize,\r\n      ));\r\n    } catch (e) {\r\n      return Left(DatabaseFailure(e.toString()));\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n## 9. Testing Strategy\r\n\r\n### 9.1 Unit Testing Architecture\r\n\r\n#### 9.1.1 Test Structure\r\n```dart\r\n// Example: Reward Bloc Test\r\nclass MockRewardRepository extends Mock implements RewardRepository {}\r\n\r\nvoid main() {\r\n  group('RewardBloc', () {\r\n    late RewardBloc rewardBloc;\r\n    late MockRewardRepository mockRepository;\r\n\r\n    setUp(() {\r\n      mockRepository = MockRewardRepository();\r\n      rewardBloc = RewardBloc(mockRepository);\r\n    });\r\n\r\n    blocTest<RewardBloc, RewardState>(\r\n      'emits [RewardLoading, RewardLoaded] when LoadRewards is added',\r\n      build: () {\r\n        when(() => mockRepository.getRewardHistory())\r\n            .thenAnswer((_) async => Right(mockRewardList));\r\n        return rewardBloc;\r\n      },\r\n      act: (bloc) => bloc.add(const LoadRewards()),\r\n      expect: () => [\r\n        const RewardLoading(),\r\n        RewardLoaded(mockRewardList),\r\n      ],\r\n    );\r\n  });\r\n}\r\n```\r\n\r\n### 9.2 Integration Testing\r\n\r\n#### 9.2.1 Firebase Testing Setup\r\n```dart\r\nclass TestFirebaseService {\r\n  static Future<void> setupFirebaseEmulator() async {\r\n    await Firebase.initializeApp(\r\n      options: DefaultFirebaseOptions.currentPlatform,\r\n    );\r\n    \r\n    FirebaseFirestore.instance.useFirestoreEmulator('localhost', 8080);\r\n    FirebaseAuth.instance.useAuthEmulator('localhost', 9099);\r\n  }\r\n}\r\n```\r\n\r\n## 10. Deployment Architecture\r\n\r\n### 10.1 CI/CD Pipeline\r\n\r\n#### 10.1.1 GitHub Actions Configuration\r\n```yaml\r\nname: Flutter CI/CD\r\n\r\non:\r\n  push:\r\n    branches: [ main, develop ]\r\n  pull_request:\r\n    branches: [ main ]\r\n\r\njobs:\r\n  test:\r\n    runs-on: ubuntu-latest\r\n    steps:\r\n      - uses: actions/checkout@v3\r\n      - uses: subosito/flutter-action@v2\r\n        with:\r\n          flutter-version: '3.24.0'\r\n      \r\n      - name: Get dependencies\r\n        run: flutter pub get\r\n      \r\n      - name: Run tests\r\n        run: flutter test --coverage\r\n      \r\n      - name: Upload coverage\r\n        uses: codecov/codecov-action@v3\r\n\r\n  build_android:\r\n    needs: test\r\n    runs-on: ubuntu-latest\r\n    steps:\r\n      - uses: actions/checkout@v3\r\n      - uses: subosito/flutter-action@v2\r\n      \r\n      - name: Build APK\r\n        run: flutter build apk --release\r\n      \r\n      - name: Upload APK\r\n        uses: actions/upload-artifact@v3\r\n        with:\r\n          name: app-release.apk\r\n          path: build/app/outputs/flutter-apk/app-release.apk\r\n\r\n  build_ios:\r\n    needs: test\r\n    runs-on: macos-latest\r\n    steps:\r\n      - uses: actions/checkout@v3\r\n      - uses: subosito/flutter-action@v2\r\n      \r\n      - name: Build iOS\r\n        run: flutter build ios --release --no-codesign\r\n```\r\n\r\n### 10.2 Environment Configuration\r\n\r\n#### 10.2.1 Environment Management\r\n```dart\r\nenum Environment { development, staging, production }\r\n\r\nclass AppConfig {\r\n  static const Environment environment = Environment.development;\r\n  \r\n  static const Map<Environment, AppSettings> _config = {\r\n    Environment.development: AppSettings(\r\n      apiBaseUrl: 'https://dev-api.example.com',\r\n      firebaseProject: 'ai-rewards-dev',\r\n      admobAppId: 'ca-app-pub-3940256099942544~3347511713', // Test ID\r\n    ),\r\n    Environment.staging: AppSettings(\r\n      apiBaseUrl: 'https://staging-api.example.com',\r\n      firebaseProject: 'ai-rewards-staging',\r\n      admobAppId: 'ca-app-pub-XXXXXXXXXXXXXXXX~XXXXXXXXXX',\r\n    ),\r\n    Environment.production: AppSettings(\r\n      apiBaseUrl: 'https://api.example.com',\r\n      firebaseProject: 'ai-rewards-prod',\r\n      admobAppId: 'ca-app-pub-XXXXXXXXXXXXXXXX~XXXXXXXXXX',\r\n    ),\r\n  };\r\n\r\n  static AppSettings get current => _config[environment]!;\r\n}\r\n```\r\n\r\n---\r\n\r\n**Document Version**: 1.0  \r\n**Last Updated**: October 30, 2025  \r\n**Status**: Draft - Pending Approval  \r\n**Dependencies**: Requirements Specification v1.0  \r\n**Stakeholders**: Technical Lead, Mobile Development Team, Firebase Team, QA Team",
  "fileStats": {
    "size": 33934,
    "lines": 1066,
    "lastModified": "2025-10-30T01:52:51.996Z"
  },
  "comments": []
}